package dev.engineeringlab.stratify.processor;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;

/**
 * Abstract base class for provider service file generation processors.
 *
 * <p>This processor auto-generates META-INF/services files for classes annotated with a provider
 * annotation (like {@code @Provider}). It discovers all provider interfaces implemented by the
 * annotated class and registers them for ServiceLoader discovery.
 *
 * <h2>How It Works</h2>
 *
 * <p>Given this annotated class:
 *
 * <pre>{@code
 * @Provider(name = "redis")
 * public class RedisMessageBroker implements MessageBrokerProvider {
 *     // ...
 * }
 * }</pre>
 *
 * <p>The processor automatically generates:
 *
 * <pre>
 * META-INF/services/com.example.MessageBrokerProvider
 * # Auto-generated by ProviderProcessor
 * com.example.redis.RedisMessageBroker
 * </pre>
 *
 * <h2>Creating a Domain-Specific Processor</h2>
 *
 * <p>Subclasses only need to specify which annotation they handle:
 *
 * <pre>{@code
 * @SupportedAnnotationTypes("dev.engineeringlab.stratify.annotation.Provider")
 * @SupportedSourceVersion(SourceVersion.RELEASE_21)
 * public class ProviderProcessor extends AbstractProviderServiceProcessor {
 *     // All logic is in the base class
 * }
 * }</pre>
 *
 * @since 1.0.0
 */
public abstract class AbstractProviderServiceProcessor extends AbstractProcessor {

  protected Messager messager;
  protected Filer filer;
  protected Elements elementUtils;
  protected Types typeUtils;

  /** Map of service interface FQN -> Set of implementation FQNs. */
  private final Map<String, Set<String>> serviceImplementations = new HashMap<>();

  /** Track processed classes to avoid duplicates. */
  private final Set<String> processedClasses = new HashSet<>();

  @Override
  public synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    this.messager = processingEnv.getMessager();
    this.filer = processingEnv.getFiler();
    this.elementUtils = processingEnv.getElementUtils();
    this.typeUtils = processingEnv.getTypeUtils();
  }

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    if (roundEnv.processingOver()) {
      writeServiceFiles();
      return false;
    }

    // Process all annotations specified in @SupportedAnnotationTypes
    for (TypeElement annotation : annotations) {
      for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) {
        if (element.getKind() == ElementKind.CLASS) {
          TypeElement classElement = (TypeElement) element;
          String className = classElement.getQualifiedName().toString();

          if (!processedClasses.contains(className)) {
            processedClasses.add(className);
            processProviderClass(classElement);
          }
        }
      }
    }

    return false;
  }

  /** Processes a provider class to find implemented provider interfaces. */
  private void processProviderClass(TypeElement classElement) {
    String implementationFqn = classElement.getQualifiedName().toString();

    // Find all implemented interfaces that are provider interfaces
    for (TypeMirror implementedInterface : classElement.getInterfaces()) {
      registerProviderInterface(classElement, implementationFqn, implementedInterface);
    }

    // Also check superclass interfaces (inherited provider interfaces)
    checkSuperclassInterfaces(classElement, implementationFqn);
  }

  /** Registers a provider implementation for a given interface. */
  private void registerProviderInterface(
      TypeElement classElement, String implementationFqn, TypeMirror interfaceType) {
    Element interfaceElement = typeUtils.asElement(interfaceType);
    if (interfaceElement instanceof TypeElement interfaceTypeElement) {
      String interfaceName = interfaceTypeElement.getSimpleName().toString();
      String interfaceFqn = interfaceTypeElement.getQualifiedName().toString();

      // Check if it's a provider interface (ends with "Provider")
      if (isProviderInterface(interfaceName)) {
        messager.printMessage(
            Diagnostic.Kind.NOTE,
            "Auto-registering " + implementationFqn + " for ServiceLoader: " + interfaceFqn,
            classElement);

        serviceImplementations
            .computeIfAbsent(interfaceFqn, k -> new HashSet<>())
            .add(implementationFqn);
      }
    }
  }

  /**
   * Determines if an interface name represents a provider interface.
   *
   * <p>Override this method to customize which interfaces are considered provider interfaces.
   *
   * @param interfaceName the simple name of the interface
   * @return true if this interface should be registered for ServiceLoader
   */
  protected boolean isProviderInterface(String interfaceName) {
    return interfaceName.endsWith("Provider");
  }

  /** Checks superclass for inherited provider interfaces. */
  private void checkSuperclassInterfaces(TypeElement classElement, String implementationFqn) {
    TypeMirror superclass = classElement.getSuperclass();
    if (superclass == null) {
      return;
    }

    Element superElement = typeUtils.asElement(superclass);
    if (!(superElement instanceof TypeElement superType)) {
      return;
    }

    String superClassName = superType.getQualifiedName().toString();
    if (superClassName.equals("java.lang.Object")) {
      return;
    }

    // Register interfaces from superclass
    for (TypeMirror inheritedInterface : superType.getInterfaces()) {
      registerProviderInterface(classElement, implementationFqn, inheritedInterface);
    }

    // Recursively check superclass's superclass
    checkSuperclassInterfaces(superType, implementationFqn);
  }

  /** Writes META-INF/services files for all discovered provider implementations. */
  private void writeServiceFiles() {
    for (Map.Entry<String, Set<String>> entry : serviceImplementations.entrySet()) {
      String serviceInterface = entry.getKey();
      Set<String> implementations = entry.getValue();

      if (implementations.isEmpty()) {
        continue;
      }

      try {
        FileObject file =
            filer.createResource(
                StandardLocation.CLASS_OUTPUT, "", "META-INF/services/" + serviceInterface);

        try (BufferedWriter writer = new BufferedWriter(file.openWriter())) {
          writer.write("# Auto-generated by " + getClass().getSimpleName() + " - DO NOT EDIT");
          writer.newLine();
          writer.write("# Provider implementations discovered at compile time");
          writer.newLine();

          for (String impl : implementations) {
            writer.write(impl);
            writer.newLine();
          }
        }

        messager.printMessage(
            Diagnostic.Kind.NOTE,
            "Generated META-INF/services/"
                + serviceInterface
                + " with "
                + implementations.size()
                + " implementation(s)");

      } catch (IOException e) {
        messager.printMessage(
            Diagnostic.Kind.ERROR,
            "Failed to write META-INF/services/" + serviceInterface + ": " + e.getMessage());
      }
    }
  }
}
